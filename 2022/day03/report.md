# Многопоточное программирование в Java.

## Класс Thread

Методы класса `Thread`:
- getName(): возвращает имя потока;
- setName(String name): устанавливаем имя потока;
-------------------------------------------------------------------------------
- getPriority(): возвращает приоритет потока;
- setPriority(int priority): устанавливает приоритет потока. В качестве аргумента передаётся число от 1 до 10. По умолчанию главному потоку выставляется средний приоритет, т.е. 5;
-------------------------------------------------------------------------------
- isAlive(): возвращает true, если поток активен;
- isInterrupted(): возвращает true, если поток был прерван;
-------------------------------------------------------------------------------
- join(): ожидает завершения потока;
- sleep(): останавливает поток на заданное количество миллисекунд;
- start(): запускает поток, используя метод run().

С помощью статического метода `Thread.currentThread()` мы можем получить текущий поток выполнения.

-------------------------------------------------------------------------------

Вызов метода `interrupt()` устанавливает статус потока, что он прерван, однако, в отличии от изменения переменной isAlive, вызов не завершает работу потока, а только устанавливает стутус, что поток прерван.

Обработка исключения в блоке `InterruptedException` автоматически сбрасывает статус потока и метод `isInterrupted()` вновь вернёт `false`. Для того чтобы избежать этой ситуации, например в цикле, можно повторно вызвать метод `interrupt()` или `break`.

-------------------------------------------------------------------------------

Вызов метода `join()` до вызова метода `start()` не приведёт к тому, что дочерний поток выполнится быстрее, ибо в `join()` есть проверка переменной `isAlive`.

Разницы между `Thread.sleep()` и `objectThread.sleep()` нет, т.к. обе команды останавливают именно тот поток, в котором были вызваны эти методы.

-------------------------------------------------------------------------------

Оператор `synchronized` синхронизирует работу потоков, может быть как частью инициализации метода, так и отдельным блоком. Каждый объект Java имеет под капотом монитор (инструмент для управления доступа к объекту). Когда выполнение кода доходит до блока `synchronized`, монитор объекта блокируется и доступ к к блоку кода имеет только один поток, который и произвёл блокировку. После выполнения блока кода с `synchronized` монитор объекта освобождается и становится доступным для других потоков.

-------------------------------------------------------------------------------

Для управления работой потоков можно использовать и методы `wait()` и `notify()`. Они используются в блоках кода, которые синхронизированы. метод `wait()` имеет смысл оформлять внутри цикла с проверкой на ожидание, чтобы избежать пробуждение потока. `notify()` необходим для уведомления ожидающего потока о том, что он может продолжать свою работу. Эти методы являются частью класса `Object`, потому и должны быть синхронизированы для работы с монитором.

-------------------------------------------------------------------------------

Помимо этого, для управления работой потоков есть семафоры. В конструктор семафора помещается количество потоков, которые могут работать одновременно. Методы `acquire()` и `release()` используются для получение разрешения от семафора для работы потоков и освобождении разрешения работы.

-------------------------------------------------------------------------------

Класс `ExecutorService` предназначен для управления определённым количеством потоков по нескольку раз, не создавая при этом новых. В общих чертах, он представляет из себя пул потоков.

Пример создания объекта, где передаваемое методу число – количество потоков, которыми объект будет располагать, но также можно поместить класс от шаблона ThreadFactory, который создаёт потоки и будет вызываться при инициализации (это самый простой сопосб создать пул потоков):

```

final ExecutorSercice executor = new Executors.newFixedThreadPool(3);

final ExecutorSercice executor = new Executors.newFixedThreadPool(3, new myThreadFactory());

```

После инициализации необходимо использовать метод `execute()`, который запустит очередь для её выполнения потоками. В самом методе необходимо добавить объект шаблона `Runnable`, который содержит в себе инструкции выполнения для потоков.

Важно помнить, что пул потоков нужно высвобождать:

```

executor.submit();

try{
    if(!executor.awaitTermination(Long.MAX_VALUE, TimeUnit.MICROSECONDS)){
        executor.shutdownNow();
    }
}
catch(InterruptedException ex){
    ...
}

```

Метод `shutdown()` не приводит к немедленному уничтожению объекта `ExecutorServie`, он заставляет его перестать принимать новые задачи и завершить работу после того, как все запущенные потоки прекратят свою работу.

Метод `shotdownNow()` пытается немедленно уничтожить все потоки, но не гарантирует, что все запущенные потоки будут уничтожены одновременно.

Метод `awaitTermination` принимает какое-то время и ожидает, пока оно не истечёт.

-------------------------------------------------------------------------------

класс `Exchanger` передаёт какую-то информацио между потоками с помощью метода `T exchange(T value)`, в которые передаётся информацию в другой поток и передаются по выходу из другого. Объект класса необходимо передавать в класс от Runnable или Thread, чтобы потоки располагали одной и той же ссылкой.